//~ //System
#include <iostream>
#include <stdio.h>
#include <cmath>
//Externals
#include <Eigen/Dense>
#include "gurobi_c++.h"
#include "json/json.h"
//~ Custom Classes
#include "Friction.h"
#include "OptProgram.h"
#include "LoopControl.h"
#include "StructuresOptProgram.h"
//#include "StructuresMain.h"
//Ros
#include <ros/ros.h>
#include "tf/tf.h"
#include <tf/transform_datatypes.h>
#include <tf/transform_listener.h>
#include "geometry_msgs/Twist.h"
#include "std_msgs/String.h"
#include "sensor_msgs/JointState.h"

//ABB Robot

#include "PracticalSocket/PracticalSocket.h" // For UDPSocket and SocketException
#include "egm/egm.pb.h" // generated by Google protoc.exe
#include "StructuresMain.h"
#include "ikfast.h" // generated by Google protoc.exe
#include "ik_fast_interface_python.h" // generated by Google protoc.exe
#include "egm.pb.h" // generated by Google protoc.exe

#pragma comment(lib, "Ws2_32.lib")      // socket lib
#pragma comment(lib, "libprotobuf.lib") // protobuf lib

#ifndef ABBROBOT_H
#define ABBROBOT_H

using namespace abb::egm;
using namespace tf;
using namespace std;
using Eigen::MatrixXd;

void CreateSensorMessage(EgmSensor* pSensorMessage, Vector3d q_pusher);
void CreateSensorMessageEmpty(EgmSensor* pSensorMessage);
void DisplayRobotMessage(EgmRobot *pRobotMessage, Vector3d& q_pusher, VectorXd& joint_states);
bool getRobotPose(UDPSocket* EGMsock, string& sourceAddress, unsigned short& sourcePort, EgmRobot* pRobotMessage, Vector3d& q_pusher, VectorXd& joint_states);
void initializeEGM(robotStruct robot_struct, Vector3d &q_pusher,  VectorXd& joint_states);
void velocityControlABB(robotStruct robot_struct, Vector3d &q_pusher, Vector3d &twist_pusher, double h);
void pauseEGM(robotStruct robot_struct, double _time, VectorXd& _joint_states);
bool getViconPose(Eigen::Vector3d& q_slider, TransformListener& listener);
bool getViconVel(Eigen::Vector3d& dq_slider, TransformListener& listener);
void initializeVicon(Vector3d &q_slider, tf::TransformListener& listener);
Eigen::Quaternion<float> toABBQuaternion(double _theta);
double toPlanarAngle(Eigen::Quaternion<float> q);
void velocityOffsetABB(Vector3d &q_pusher, Vector3d &twist_pusher, double v_eq, double radius, double d);
void CreateSensorJointsMessage(EgmSensor* pSensorMessage, VectorXd joints);
void jointControlABB(robotStruct robot_struct, VectorXd &joints);
void publish_joints(VectorXd joint_states, ros::Publisher exec_joint_pub);
void ikfast_pusher(Vector3d& _q_pusher, VectorXd& joint_states, VectorXd& q0, bool& is_success, tf::TransformListener& listener);
#endif
