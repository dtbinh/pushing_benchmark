classdef MPPI < dynamicprops
    %TODO: Add 
    properties (Constant)
        K = 1200;
        T = 1.5;
        dt = 0.05;
        lambda = .1;
    end

    properties
        N;
        U;
        X;
        F;
        u;
        x;
        Sigma;
        t_star;
        x_star;
    end

    methods
        function obj = MPPI(F, t_star, x_star)
            obj.F = F;
            obj.N =  floor(obj.T/obj.dt);
            obj.u = [.05*ones(1, obj.N); zeros(1, obj.N)];
            obj.Sigma =  1*diag([.005,.01]);%.05*eye(obj.F.a_length); 
            obj.t_star = t_star;
            obj.x_star = x_star;
        end
        
        function state = find_nominal_state(obj, t)
            diff = abs(obj.t_star - t);
            [val ind] = min(diff);
            state = obj.x_star(ind,:);
        end
        
        function u_control = controller(obj, x0, t0)
            
            %1. Initialize variables
            S = zeros(obj.K,1);
            u = obj.u;
            x = zeros(obj.F.x_length, obj.N);
            %Loop through sample trajectories
            for k=1:obj.K
                x(:, 1) = x0';
                %rng default  % For reproducibility
                E{k} = mvnrnd(zeros(obj.F.a_length,1), obj.Sigma, obj.N)';
                %Rollout dynamics and compute cost
                t = t0;
                for n=2:obj.N+1
                    xd = obj.find_nominal_state(t);
                    xn = obj.F.get_next_state_b(x(:, n-1), u(:,n-1) + E{k}(:,n-1), obj.dt);
                    x(:, n) = xn';
                    S(k) = S(k) + obj.F.q_cost(x(:,n),u(:,n-1),xd') + (1*obj.lambda*u(:, n-1)'*inv(obj.Sigma)*E{k}(:,n-1));
                    t = t + obj.dt;
                end
                S(k) = S(k) + obj.F.phi_cost(x(:,obj.N+1),u(:,n-1),xd');
                obj.U{k} = u + E{k};
                obj.X{k} = x;
            end
            
            [beta, index] = min(S);
            eta = 0;
            for k=1:obj.K
                eta = eta + exp(-1/obj.lambda *(S(k)-beta));
            end
            
            for k=1:obj.K
                w(k) = (1/eta)*exp(-1/obj.lambda *(S(k)-beta));
            end   
            
            for n=1:obj.N
                W = 0;
                for k=1:obj.K
                    W = W + w(k)*E{k}(:, n);
                end
                u(:, n) = u(:, n) + W;%w(k)*E{k}(:, n);
            end

            
            %Rollout dynamics and compute cost
            t = t0;
            for n=2:obj.N+1
                xd = obj.find_nominal_state(t);
                xn = obj.F.get_next_state(x(:, n-1), u(:,n-1), obj.dt);
                x(:, n) = xn';
                t = t + obj.dt;
            end
            %save best state and action
            obj.x = x;%obj.X{index};
            obj.u = u;%obj.U{index};
            
            u_control = u(:,1);
%             
            for n=2:obj.N
                u(:, n-1) = u(:, n);
            end
            u(:, n-1) = 0;
            obj.u = u;
            
            
            if u_control(1)<0
                disp('neg vel');
            end
  
        end
        
        function video_setup()           
            if obj.doVid
                obj.writerObj = VideoWriter('qlearnVid.mp4','MPEG-4');
                obj.writerObj.FrameRate = 60;
                open(obj.writerObj);
            end
        end

    end
end