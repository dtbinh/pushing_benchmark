clear
close all
clc

%simulation parameters
x0_c = [-0.05;0.0;-pi*.5;0]*1;
tspan = 1;
dt = 0.05;
N = tspan/dt;

%Define Dynamical system
% sys = Pendulum();

pusher = PointPusher();
object = Square();
surface = Surface();
planar_system = PlanarSystem(pusher, object, surface);
planner = Planner(planar_system, 'Straight', 0.05); 
sys = Simulator(planar_system, 'MPPI_nonlinear_error_1');

x0 = planar_system.coordinateTransformCS(x0_c);

%Define controller object
MPPI = MPPI(0.5, 0.05, 1200, .1, diag([.015,.015]), @sys.get_next_state_nonlinear_error_b, @sys.q_cost_nonlinear_error, @sys.phi_cost_nonlinear_error, @sys.u_constraints_nonlinear_error);

x = zeros(N+1, length(x0));
x(1,:) = x0';
sys.x_star = planner.xs_star;
sys.u_star = planner.us_star;
sys.t_star = planner.t_star;
sys.initialize_plot(x0, planner.xs_star(1,:)', MPPI);
t = zeros(N+1,1);

MPC_trajectories = {};

for i=1:N
    t(i)
    [x_star, u_star] = sys.find_nominal_state(t(i));
    %
    x_bar = x(i,:) - x_star';
    %get action 
    u_bar = MPPI.controller(x_bar, t(i));
    %
    u = u_star + u_bar;
    
    %get next state 
    x(i+1,:) = sys.get_next_state_b(x(i,:)', u, dt);
    t(i+1) = t(i) + dt;
    
    MPC_trajectories{i} = MPPI.X;
    MPC_best{i} = MPPI.x;
    weights{i} = MPPI.w;
    des_traj{i} = x_des;
    
    
    sys.update_plot(x(i+1,:), MPPI, x_des, t(i));
end

sys.xs_state = x;
sys.t = t;

sys.Animate1pt(planner.xs_star, MPC_trajectories, MPC_best, MPPI)